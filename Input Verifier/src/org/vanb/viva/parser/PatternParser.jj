/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.6";  static = false;}PARSER_BEGIN( PatternParser )package org.vanb.viva.parser;

import org.vanb.viva.patterns.*;
import org.vanb.viva.expressions.*;
import org.vanb.viva.utils.*;import java.util.*;

public class PatternParser{
    private SymbolTable<Class<?>> symbols = new SymbolTable<Class<?>>();

    private String getPosition( Token token )
    {
        return "At line " + token.beginLine + " column " + token.beginColumn + ": ";    }
      
}PARSER_END( PatternParser )SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ("-")? ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        <DECIMAL_FLOATING_POINT_LITERAL>
      | <HEXADECIMAL_FLOATING_POINT_LITERAL>
  >
|
  < #DECIMAL_FLOATING_POINT_LITERAL:
        ("-")? (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <DECIMAL_EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<DECIMAL_EXPONENT>)? ["f","F","d","D"]
  >
|
  < #DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < #HEXADECIMAL_FLOATING_POINT_LITERAL:
        "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
      | "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
  >
|
  < #HEXADECIMAL_EXPONENT: ["p","P"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/* IDENTIFIERS */
TOKEN :
{    < DOUBLE : "double" >
|   < INTEGER : "integer" >
|   < INT : "int" >
|   < LONG : "long" >
|   < FLOAT : "float" >
|   < STRING : "string" >
}

TOKEN :
{
  < IDENTIFIER: <LETTER> (<PART_LETTER>)* >
|
  < #LETTER:
      [  // all chars for which Character.isIdentifierStart is true
         "$",
         "A"-"Z",
         "_",
         "a"-"z"
      ]
  >
|
  < #PART_LETTER:
      [  // all chars for which Character.isIdentifierPart is true
         "$",
         "0"-"9",
         "A"-"Z",
         "_",
         "a"-"z"
      ]
  >
}
PatternList multilinePattern() :{ 
    PatternList plist = new PatternList();
    Pattern p; 
}{
  ( 
      p=singlePattern()   
      { 
          plist.addPattern( p );
      } 
  )*
  {
      return plist;
  }
}

Pattern singlePattern() :
{
    Pattern pattern;
    PatternListController controller;
    PatternList plist;
    ExpressionNode exp=null;
}
{
  (
    "{" "[" controller=qualifier() "]" { symbols.addLevel(); } plist=multilinePattern() [ "[" exp=constraint( true ) "]" ] "}"
    {
        symbols.removeLevel();
        controller.setPatternList( plist );
        if( exp!=null ) controller.addConstraint( exp );
        pattern = controller;
    }
  |       plist=simplePattern() ";"
    {
        controller = new SingleLineController();
        controller.setPatternList( plist );
        pattern = controller;
    }
  )
  {
      return pattern;
  }}PatternListController qualifier() :{
    PatternListController pattern=null;
    Pattern term=null;
    ExpressionNode exp = null;
}{
  (
    "*" exp=expression( false )
    {
        CountController count = new CountController();
        count.setCountExpression( exp );
        pattern = count;
    }
  |
    "=" {symbols.addLevel();} term=simplePattern()
    {
        symbols.removeLevel();
        MatchController match = new MatchController();
        match.setTerminatingPattern( term );
        pattern = match;
    }  )
  {
      return pattern;
  } }

PatternList simplePattern() :
{
    PatternList plist = new PatternList();
    PatternList innerlist = null;
    PatternListController controller = null;
    ExpressionNode exp = null;
    Token token;
    ValuePattern value = null;
}
{
  (
	  (	    "<" "[" controller=qualifier() "]" { symbols.addLevel(); } innerlist=simplePattern() [ "[" exp=constraint( true ) "]" ] ">"
	    {
	        symbols.removeLevel();
	        controller.setPatternList( innerlist );
	        if( exp!=null ) controller.addConstraint( exp );
	        plist.addPattern( controller );
	    }
	  )
	  |
	  ( 
	      token=< IDENTIFIER > [ ":" value=type() ]
	      {
	          String name = token.image;
	          if( value==null ) value = new IntegerPattern();
	          value.setName( name );
	          plist.addPattern( value );
	          boolean unique = symbols.add( name, value.getType() );
	          if( !unique )
	          {
	              throw new ParseException( getPosition(token) + "Variable " + name + " is already defined." );
	          }
	          value = null;
	      } 
	      [
	          "(" exp=constraint( false )
			      {
			          if( exp!=null ) plist.addConstraint( exp );
			          exp = null;
			      }
			      (
			            "," exp=constraint( false )
			            {			                if( exp!=null ) plist.addConstraint( exp );
			                exp = null;
			            }			      )*
		      ")"
	      ] 
	   )
  )+
  {
      return plist;
  }
}

ValuePattern type() :
{
  ValuePattern pattern = null;
}
{  (
      < DOUBLE >  { pattern = new DoublePattern(); }
  |   < FLOAT >   { pattern = new FloatPattern(); }
  |   < LONG >    { pattern = new LongPattern(); }
  |   < INT >     { pattern = new IntegerPattern(); }
  |   < INTEGER > { pattern = new IntegerPattern(); }
  |   < STRING >  { pattern = new StringPattern(); }
  )
  {
      return pattern;  }
}ExpressionNode constraint( boolean isCumulative ) :
{
    ExpressionNode lhs, rhs;
    BinaryOperatorNode op;
}
{
  lhs=orConstraint( isCumulative ) 
  ( 
      "||" rhs=orConstraint( isCumulative )
      {
          op = new OrNode();
          op.instantiate( lhs, rhs );
          lhs = op;
      }
  )*
  {
      return lhs;
  }
}

ExpressionNode orConstraint( boolean isCumulative ) :
{
    ExpressionNode lhs, rhs;
    BinaryOperatorNode op;
}
{
  lhs=simpleConstraint( isCumulative ) 
  ( 
      "&&" rhs=simpleConstraint( isCumulative )
      {
          op = new AndNode();
          op.instantiate( lhs, rhs );
          lhs = op;
      }
  )*
  {
      return lhs;
  }
}
ExpressionNode simpleConstraint( boolean isCumulative ) :
{
    ExpressionNode lhs, rhs;
    BinaryOperatorNode op, newop;
}
{
  lhs=expression( isCumulative ) op=boolop() rhs=expression( isCumulative )
  {
      op.instantiate( lhs, rhs );
      lhs = rhs;
  }
  ( 
      newop=boolop() rhs=expression( isCumulative )
      {
	      newop.instantiate( lhs, rhs );
	      BinaryOperatorNode andop = new AndNode();
	      andop.instantiate( op, newop );
	      op = andop;
	      lhs = rhs;
      }
  )*
  {
      return op;
  }}

BinaryOperatorNode boolop() :
{
    BinaryOperatorNode op = null;
    Token token;
}
{    (
      token = ">" { op = new GreaterThanNode(); op.operator = token.image; }
    |
      token = "<" { op = new LessThanNode(); op.operator = token.image; }
    |
      token = ">=" { op = new GreaterThanEqualToNode(); op.operator = token.image; }
    |
      token = "<=" { op = new LessThanEqualToNode(); op.operator = token.image; }
    |
      token = "=" { op = new EqualToNode(); op.operator = token.image; }
    |
      token = "==" { op = new EqualToNode(); op.operator = token.image; }
    |
      token = "!=" { op = new NotEqualToNode(); op.operator = token.image; }
    |
      token = "<>" { op = new NotEqualToNode(); op.operator = token.image; }
    |
      token = "%"  { op = new RegExpNode(); op.operator = token.image; }       )
    {
        return op;
    }
}

ExpressionNode expression( boolean isCumulative ) :
{
    ExpressionNode lhs, rhs;
    BinaryOperatorNode op;
}
{
  lhs=term(isCumulative) 
  ( 
      op=addop() rhs=term(isCumulative)
      {
          op.instantiate( lhs, rhs );
          lhs = op;
      } 
  )*
  {
      return lhs;
  }
}

BinaryOperatorNode addop() :
{
    BinaryOperatorNode op = null;
    Token token;
}{
  (    token = "+" { op = new PlusNode(); op.operator = token.image; }
  |
    token = "-" { op = new MinusNode(); op.operator = token.image; }
  )
  {
      return op;
  }}

ExpressionNode term( boolean isCumulative ) :
{
    ExpressionNode lhs, rhs;
    BinaryOperatorNode op;
}
{
  lhs=factor(isCumulative) 
  ( 
      op=multop() rhs=factor(isCumulative)
      {
          op.instantiate( lhs, rhs );
          lhs = op;
      } 
  )*
  {
      return lhs;
  }
}

BinaryOperatorNode multop() :
{
    BinaryOperatorNode op = null;
    Token token;
}
{
  (
    token = "*" { op = new TimesNode(); op.operator = token.image; }
  |
    token = "/" { op = new DivideNode(); op.operator = token.image; }
  )
  {
      return op;
  }
}

ExpressionNode factor( boolean isCumulative ) :
{
    Token token;
    ExpressionNode node;
    Object value;
    String lit;
}
{
  (
    token=< IDENTIFIER >  node=named( token.image, isCumulative )
  |
    token=< INTEGER_LITERAL >
    {
        boolean islong = token.image.toUpperCase().endsWith( "L" );
        try
        {
            if( islong )
            {
                value = new Long( token.image.substring( 0, token.image.length()-1 ) );
            }
            else
            {
                value = new Integer( token.image );
            }
        }
        catch( Exception e )
        {
            throw new ParseException( getPosition(token) + "Unable to parse " + token.image 
                + " as " + (islong ? "a Long" : "an Integer") );
        }
        
        node = new ConstantNode( value );
    }
  |
    token=< FLOATING_POINT_LITERAL >
    {
        try
        {
            value = new Double( token.image );
        }
        catch( Exception e )
        {
            throw new ParseException( getPosition(token) + "Unable to parse " + token.image + " as a Double" );
        }
        node = new ConstantNode( value );
    }
  |
    token=< CHARACTER_LITERAL >
    {
        lit = token.image;
        if( lit.startsWith( "'" ) ) lit = lit.substring(1);
        value = new Integer( (int)(lit.charAt(0)) );
        node = new ConstantNode( value );
    }
  |
    token=< STRING_LITERAL >
    {
        lit = token.image;
        if( lit.startsWith( "\"" ) ) lit = lit.substring(1);
        if( lit.endsWith( "\"" ) ) lit = lit.substring( 0, lit.length()-1);
        node = new ConstantNode( lit );
    }
  |
    "(" node=expression(isCumulative) ")"
    {        node = new ParenthesesNode( node );
    }   )
  {
      return node;
  }}

ExpressionNode named( String name, boolean isCumulative ) :
{    ExpressionNode node = null;
    ExpressionNode subscript = null;
    ExpressionNode parm = null;
    LinkedList<ExpressionNode> parms = new LinkedList<ExpressionNode>();
    Class<? > type;
}
{  (     "[" subscript=expression(isCumulative) "]"
     {
         type = symbols.lookup( name );
         if( type==null )
         {
             throw new ParseException( getPosition(token) + "Unknown identifier: " + name );
         }

         if( !subscript.returnType().equals( Integer.class ) )
         {             throw new ParseException( getPosition(token) + "Subscript must be Integer, not " + subscript.returnType() );
         }
         node = new SubscriptNode( name, type, subscript );     }
  |
     "(" parm=expression(isCumulative) {parms.add(parm);} ("," parm=expression(isCumulative) {parms.add(parm);} )* ")"
     {         type = symbols.lookup( name );
         if( type==null )
         {
             throw new ParseException( getPosition(token) + "Unknown identifier: " + name );
         }
         node = isCumulative ? new CumulativeFunctionNode( name, type, parms )
                             : new InlineFunctionNode( name, type, parms );
     }
  |
     {         type = symbols.lookup( name );
         if( type==null )
         {
             throw new ParseException( getPosition(token) + "Unknown identifier: " + name );
         }
         node = new VariableNode( name, type );
     }     
  )
  {
      return node;  }
}
